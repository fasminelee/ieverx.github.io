<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta viewport="width=device-width, initial-scale=1" />

    
    <title>在C&#43;&#43;中实现Haskell的map函数 | 天外天</title>
    

    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/code.github.css">
</head>

<body>
    <div class="container">
        <div class="block-container">
            <div id="header" class="header">
    <div class="header-container">
        <div class="brand">
            <h1 class="u-link">
                <a href="/">天外天</a>
            </h1>
        </div>
        <div class="nav-container">
            <div class="nav">
                <div class="u-link nav-item">
                    <a href="/">home</a>
                </div>
                <div class="u-link nav-item">
                    <a href="/tags">tags</a>
                </div>
                
                <div class="u-link nav-item">
                    <a href="https://github.com/ieverx">project</a>
                </div>
                
            </div>
            <div class="clearfix"></div>
        </div>
    </div>
</div>
            
<div class="block-single">
    <div class="post">    
    <h1 class="post-title">在C&#43;&#43;中实现Haskell的map函数</h1>
    <div class="post-meta">
    <span class="post-date">2015.9.19</span>
    
        &middot;
        
        <span class="post-tag u-link">
            <a href="/tags/haskell">Haskell</a>
        </span>
        
        <span class="post-tag u-link">
            <a href="/tags/c&#43;&#43;">C&#43;&#43;</a>
        </span>
        
    
</div>
    <div class="post-content">
        <p>C++11中引入了lambda，类似如下的语法</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="p">[</span><span class="n">value</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>
<p>其中，<code>[]</code>中的部分，是捕获外界变量，<code>()</code>中的部分则是参数，<code>-&gt;</code>表明返回类型，<code>{}</code>中是函数体。</p>

<p>正好这几天在看Haskell，于是想要在C++中实现Haskell中的<code>map</code>函数。Haskell中，<code>map</code>的的效果与下面的代码效果相同，</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">map</span> <span class="ow">::</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">b</span><span class="p">]</span>
<span class="nf">map</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">map</span> <span class="nf">f</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">f</span> <span class="nf">x</span><span class="kt">:</span> <span class="nf">map</span> <span class="nf">f</span> <span class="nf">xs</span></code></pre></div>
<p>实际上是一个列表中的所有元素都用给定的函数进行计算，其结果保存为一个新的列表。</p>

<p>我期望最终的<code>map</code>函数，可以进行这样的调用</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// lambda，多态
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ir</span> <span class="o">=</span> <span class="n">map</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">},</span> <span class="n">int_vec</span><span class="p">);</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">br</span> <span class="n">map</span><span class="p">([](</span><span class="kt">double</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">},</span> <span class="n">double_vec</span><span class="p">);</span>

<span class="c1">// 函数指针
</span><span class="c1"></span><span class="kt">int</span> 
<span class="nf">f</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span>
 
<span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ir2</span> <span class="o">=</span> <span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">string_vec</span><span class="p">);</span>

<span class="c1">// functor
</span><span class="c1"></span><span class="k">struct</span> <span class="n">F</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">5</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ir3</span> <span class="o">=</span> <span class="n">map</span><span class="p">(</span><span class="n">F</span><span class="p">(),</span> <span class="n">int_vec</span><span class="p">);</span>
</code></pre></div>
<p>我第一次想到的函数声明是这个样子的</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">R</span><span class="o">&gt;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span><span class="n">R</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">);</span>
</code></pre></div>
<p>这个声明的问题在于，<code>R f(T)</code>是个函数指针，不接受lambda函数和functor，让人很无奈。于是尝试将类型改为function<R(T)>，也就是下面这样（之后省略template说明）</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span><span class="n">function</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">);</span>
</code></pre></div>
<p>现在3中方式都可以了，但是问题是，需要强制类型转换。这就比较痛苦了。至此陷入了困境。然后我想C++标准库库中是有可以传入lambda的函数的。于是我打开了<code>algorithm</code>，里面有个<code>for_each</code>函数，其声明是这样的</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_InIt</span><span class="p">,</span>
	<span class="k">class</span> <span class="nc">_Fn1</span><span class="o">&gt;</span> <span class="kr">inline</span>
	<span class="n">_Fn1</span> <span class="n">for_each</span><span class="p">(</span><span class="n">_InIt</span> <span class="n">_First</span><span class="p">,</span> <span class="n">_InIt</span> <span class="n">_Last</span><span class="p">,</span> <span class="n">_Fn1</span> <span class="n">_Func</span><span class="p">)</span>
</code></pre></div>
<p>也就是将函数类型作为多模板参数，于是我也将我的声明修改了一下</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">);</span>
</code></pre></div>
<p>然后又报错了，C++编译器无法推断出R的类型。</p>

<p>其实从Haskell的<code>map</code>的类型可以看出来，我们并不需要3个模板参数，输入类型T，输出类型R，函数类型F，是有关系的，<code>F(T) = R</code>，最开始，我是使用T和R来表示F，并不是很成功。从它们的关系来看，使用F和T表示R，相比之下，要比用F，R表示T来的直白的多。现在的问题是，如何使用C++的语法来表示R。</p>

<p>C++11中有个<code>decltype</code>，可以用来表示一个类型。如下</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 声明一个x类型的y
</span><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="c1">// 与下面一行功能相同
</span><span class="c1"></span><span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

<span class="c1">// 表明函数的返回类型
</span><span class="c1"></span><span class="k">auto</span> 
<span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">)</span>
 <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">foo</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="p">;</span>
</code></pre></div>
<p>最后一行，则使用了<code>decltype</code>来指明函数的返回类型和<code>foot(t)</code>的类型一样。那么，我们就可以写出<code>map</code>的函数声明了</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">f_map</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">()))</span><span class="o">&gt;</span>
</code></pre></div>
<p>其中<code>decltype(f(T()))</code>，<code>T()</code>是T类型的无参构造函数。当然也可以是用<code>*begin(list)</code>或者<code>*list.end()</code>等等，<code>decltype</code>与<code>sizeof</code>类似，不会对操作数进行求值。</p>

<p>最终的完整函数是这这样的</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">f_map</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="k">decltype</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">()))</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">()))</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">list</span><span class="p">);</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="n">list</span><span class="p">);</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>现在的实现的是map，当时我还想实现更加一般化的<code>fmap</code></p>
<div class="highlight"><pre class="chroma"><code class="language-hs" data-lang="hs"><span class="kr">class</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="kr">where</span>
	<span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">f</span> <span class="nf">b</span></code></pre></div>
<p><code>fmap</code>并没有一个统一的实现，对于列表而言，<code>fmap</code>的实现就是<code>fmap = map</code>。注意，这里<code>Functor</code>和C++中的<code>Functor</code>不是一个概念。</p>

<p>当然Haskell中的<code>Functor</code>在C++中不存在，我只是想写一个这种模式，比如对于一些容器，如<code>set</code>，<code>map</code>等等，可以进行<code>map</code>操作（实际上，这些容器，可以被定义为Haskell中的<code>Functor</code>）。但最后我放弃了，因为在C++中，这些容器并不具体有共同的基类，我可以写出函数声明，但是实现却无法统一。</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">C</span><span class="p">,</span> <span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">mymap</span> <span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">C</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">C</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">()))</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>其实标准库中已经有了类似的函数，就是<code>transform</code>，不过<code>transform</code>并不返回值，而是通过一个指针，修改外部的变量</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
<span class="n">transform</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">result</span><span class="p">),</span>
		<span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="p">});</span>
</code></pre></div>
<p><code>result</code>就是map后返回的结果。</p>

<p>总体来说，由于C++和Haskell的设计理念并不相同，Haskell中的<code>fmap</code>无法（至少我无法）完全在C++中实现，而<code>map</code>由于限制较少，其实现没有问题。此外，C++的标准库中其实提供的了许多与Haskell中功能的相似的函数，但是名字并不相同，而且细节略有差异。C++的容器操作，一般是需要提供指明起止位置的iterator，对一个范围进行操作。而Haskell由于值不可修改，因此均是对所有元素进行操作的，最后返回新值。</p>

    </div>
</div>
</div>

<h2 style="color: #777">评论</h2>
<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "evercoding" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


            
        </div>
    </div>
    <div id="footer">
    <div class="footer-container">
        <div class="support">
            <div class="powered-by">本站由 <a href="https://gohugo.io">Hugo</a> 驱动</div>
            <div class="theme">采用 <a href="https://github.com/codvim">ink</a> 主题</div>
        </div>
    </div>
</div>
    
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-54098391-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>

</body>
</html>