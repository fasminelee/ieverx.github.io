<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta viewport="width=device-width, initial-scale=1" />

    
    <title>ActiveMQ笔记 | 天外天</title>
    

    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/code.github.css">
</head>

<body>
    <div class="container">
        <div class="block-container">
            <div id="header" class="header">
    <div class="header-container">
        <div class="brand">
            <h1 class="u-link">
                <a href="/">天外天</a>
            </h1>
        </div>
        <div class="nav-container">
            <div class="nav">
                <div class="u-link nav-item">
                    <a href="/">home</a>
                </div>
                <div class="u-link nav-item">
                    <a href="/tags">tags</a>
                </div>
                
                <div class="u-link nav-item">
                    <a href="https://github.com/ieverx">project</a>
                </div>
                
            </div>
            <div class="clearfix"></div>
        </div>
    </div>
</div>
            
<div class="block-single">
    <div class="post">    
    <h1 class="post-title">ActiveMQ笔记</h1>
    <div class="post-meta">
    <span class="post-date">2014.7.17</span>
    
        &middot;
        
        <span class="post-tag u-link">
            <a href="/tags/activemq">ActiveMQ</a>
        </span>
        
        <span class="post-tag u-link">
            <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a>
        </span>
        
        <span class="post-tag u-link">
            <a href="/tags/%E7%AC%94%E8%AE%B0">笔记</a>
        </span>
        
    
</div>
    <div class="post-content">
        

<p>实验室的项目需要使用ActiveMQ，目的是为了进行一些耗时间的处理时，不会阻塞程序的主流程。调研ActiveMQ的工作就交给我来做了。</p>

<p>我们使用ActiveMQ，需要达到的目的有这么几个</p>

<ul>
<li>主流程发送消息，不阻塞</li>
<li>可用于集群</li>
<li>故障恢复</li>
<li>负载均衡</li>
</ul>

<p>从网上看了一些资料，ActiveMQ可以满足我们的要求</p>

<h1 id="first-step">First Step</h1>

<p>从<a href="http://activemq.apache.org">ActiveMQ官网</a>下载即可，目前的最新版本是5.10.0。我下载了Windows版本，进入bin目录，运行</p>

<pre><code>activemq start
</code></pre>

<p>即可启动一个ActiveMQ的Broker。注意，需要设置环境变量<code>JAVA_HOME</code>。</p>

<h1 id="发送接收消息">发送接收消息</h1>

<p>这一步应该是初接触ActiveMQ最想要做的事情。我们首先需要一个消息的发送者，同时需要一个消息的接受者。不多说，直接贴代码</p>

<pre><code>// Sender.java
import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.DeliveryMode;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.MessageProducer;
import javax.jms.Session;
import javax.jms.TextMessage;

import org.apache.activemq.ActiveMQConnection;
import org.apache.activemq.ActiveMQConnectionFactory;

public class Sender {
    private static final String HOST = &quot;tcp://localhost:61616&quot;; // ActiveMQ的监听地址，

    public static void main(String[] args) throws InterruptedException {
        ConnectionFactory factory; // JMS连接的工厂
        Connection conn = null; // JMS连接
        Session session; // JMS会话
        Destination destination; // 目的地，对于PTP模式，目的地是Queue；对于订阅模式，目的地是Topic
        MessageProducer producer; // 生产者

        factory = new ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_USER, ActiveMQConnection.DEFAULT_PASSWORD, HOST);

        try {
            conn = factory.createConnection();
            conn.start(); // 必须显式调用start方法
            session = conn.createSession(true, Session.AUTO_ACKNOWLEDGE);

            destination = session.createQueue(&quot;Test&quot;);
            producer = session.createProducer(destination);
            producer.setDeliveryMode(DeliveryMode.PERSISTENT); // 设置消息持久化
            for (int i = 0;; i+=2) {
                send(session, producer, i);
                Thread.sleep(1000);
            }
        } catch (JMSException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (JMSException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }

    static void send(Session session, MessageProducer producer, int label) {
        try {
            String s = &quot;消息: &quot; + label;
            TextMessage msg = session.createTextMessage(s);
            System.out.println(&quot;sending: &lt;&quot; + s + &quot;&gt;&quot;);
            producer.send(msg);
            session.commit(); // 提交之后，消息才会发送。之后立即进入下一个事务
        } catch (JMSException e) {

        }

    }
}


// Reciever.java
import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.MessageConsumer;
import javax.jms.Session;
import javax.jms.TextMessage;

import org.apache.activemq.ActiveMQConnection;
import org.apache.activemq.ActiveMQConnectionFactory;

public class Reciever {

    private static final String HOST = &quot;tcp://localhost:61616&quot;;

    public static void main(String[] args) throws InterruptedException {
        ConnectionFactory factory;
        Connection conn = null;
        Session session = null;
        Destination destination = null;
        MessageConsumer consumer;
        factory = new ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_USER, ActiveMQConnection.DEFAULT_PASSWORD, HOST);
        try {
            conn = factory.createConnection();
            conn.start();
            session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
            destination = session.createQueue(&quot;Test&quot;);
            consumer = session.createConsumer(destination);

            for (;;) {
                try {
                    TextMessage msg = (TextMessage)consumer.receive(1000);
                    if (msg != null) {
                        System.out.println(&quot;recieved: &quot; + msg.getText());
                    }
                    Thread.sleep(3000);
                } catch (IllegalStateException e) {

                }
            }

        } catch (JMSException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (JMSException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>

<p>两段代码，非常容易，这里都是使用点对点（PTP）方式，一个消息只能由一个接受者接收并处理。其中使用过的API都是JMS的标准接口，可以查看<a href="http://docs.oracle.com/javaee/7/api/">JMS的API doc</a>来获取更多信息。注释中，有一句“设置消息持久化”，所谓的消息持久化，是指将消息保存介质中，即使broker突然死掉了，重新启动broker之后，也可以获得之前的未处理的消息，持久化的方式在配置文件一节会说到</p>

<h1 id="配置文件">配置文件</h1>

<p>有了初步认识之后，再来看看配置文件。我主要关注<code>broker</code>这个节点，这个节点的属性<code>brokerName</code>应该是唯一的，<code>dataDirectory</code>指定了当前broker存放数据（比如持久化的消息）的目录。</p>

<h2 id="persistenceadapter节点">persistenceAdapter节点</h2>

<p>这个节点配置消息持久化的方式，有AMQ、KahaDB、JDBC、LevelDB四种，从5.4版本起，KahaDB作为默认持久化方式。其中，JDBC是将消息持久化到数据库，KahaDB和LevelDB是基于文件的本地数据库，而AMQ则是一种文件存储形式。具体可以参考<a href="http://blog.csdn.net/xyw_blog/article/details/9128219">ActiveMQ持久化方式</a>。</p>

<h2 id="transportconnectors">transportConnectors</h2>

<p>这个节点配置客户端连接到ActiveMQ Broker的方式。ActiveMQ支持多种连接方式，包括tcp、vm、amqp、stomp、mqtt等多种。一个连接是一个<code>transportConnector</code>节点，每个Broker可以配置多个连接，连接最重要的是<code>uri</code>属性，其指明了客户端连接Broker时的地址。具体请参见官方文档<a href="http://activemq.apache.org/configuring-transports.html">Configuring Transports</a>。</p>

<h1 id="集群">集群</h1>

<p>集群分为两种，一种是Master Slave Cluster，另一种是Broker Cluster。</p>

<h2 id="master-slave-cluster">Master Slave Cluster</h2>

<p>主从模式，可以完成故障恢复，但是没有负载均衡的能力，即同一时刻只有一个Broker（Master）在处理，其他的Broker等待（只是复制Master的状态，但是不进行任何处理）。主从模式又可以分为三种</p>

<h3 id="pure-master-savle-cluster">Pure Master Savle Cluster</h3>

<p>这是最简单的方式，这种方式下，只能有一个Slave Broker。Master无需额外配置，Slave可以采用如下的配置文件</p>

<pre><code>&lt;broker masterConnectorURI=&quot;tcp://masterhost:61617&quot; shutdownOnMasterFailure=&quot;false&quot;&gt; 
    ...
    &lt;transportConnectors&gt;
        &lt;transportConnector uri=&quot;tcp://slavehost:61616&quot;/&gt;
    &lt;/transportConnectors&gt;
&lt;/broker&gt;
</code></pre>

<p>其中，<code>masterConnectorURI</code>指明了Master，<code>shutdownOnMasterFailure</code>指明在Master失效后，Slave是停止还是成为新的Master继续运行。</p>

<p>在客户端连接的时候，应该采用<code>failover://(tcp://masterhost:61617,tcp://slavehost:61616)?randomize=false</code>作为URL连接ActiveMQ</p>

<h3 id="shared-file-system-master-slave">Shared File System Master Slave</h3>

<p>共享文件系统的主从模式，这个模式是多个Broker使用相同的目录作为消息持久化的存储地址，利用文件锁实现主从模式。获得文件锁的Broker是当前的Master，Master失效后，其余的Slave中，获得文件锁的Broker成为新的Master。所有Broker的配置文件中，都需要做如下配置</p>

<pre><code>&lt;persistenceAdapter&gt;
    &lt;kahaDB directory=&quot;/activemq/data&quot;/&gt;
&lt;/persistenceAdapter&gt; 
</code></pre>

<p>其中<code>directory</code>属性值必须保持相同，可以采用其他的持久化方式</p>

<h3 id="jdbc-master-slave">JDBC Master Slave</h3>

<p>和Shared File System Master Salve相同，只不过是持久化方式改为了数据库，配置如下</p>

<pre><code>&lt;broker ...&gt;
    &lt;persistenceAdapter&gt;
        &lt;jdbcPersistenceAdapter dataSource=&quot;#mysql-ds&quot;/&gt; 
    &lt;/persistenceAdapter&gt; 
&lt;/broker&gt;
&lt;bean id=&quot;mysql-ds&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?relaxAutoCommit=true&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;username&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;passward&quot;/&gt;
    &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt;
&lt;/bean&gt; 
</code></pre>

<p>其中<code>dataSource</code>指定了数据库源，需要在配置文件中设置一个<code>id</code>与之相等的<code>bean</code>配置详细的数据库信息。</p>

<h2 id="broker-cluster">Broker Cluster</h2>

<p>多个Broker组成网络，这种集群有负载均衡的能力，采用这种方式的集群，在一个Broker失效后，会连接到另外一个Broker上，但是失效的Broker上的消息，在该Broker恢复之前，不能被其他Broker获得并处理。失效的Broker恢复之后，持久化消息恢复，非持久化消息将会丢失。</p>

<p>这种集群有动态发现和静态发现两种配置方式。区别是，静态发现需要配置在配置文件中制定所有的Broker的地址，而动态发现则无需指明，由Broker自己去发现其他的Broker。</p>

<p>静态配置文件如下</p>

<pre><code>&lt;broker brokerName=&quot;receiver&quot; persistent=&quot;false&quot; useJmx=&quot;false&quot;&gt;
    &lt;transportConnectors&gt;
        &lt;transportConnector uri=&quot;tcp://localhost:61616&quot;/&gt;
    &lt;/transportConnectors&gt;
    &lt;networkConnectors&gt;
        &lt;networkConnector uri=&quot;static:(tcp://localhost:61616,tcp://remotehost:61616)&quot;/&gt;
    &lt;/networkConnectors&gt;
&lt;/broker&gt; 
</code></pre>

<p>此时客户端连接时，应使用<code>failover://static://(tcp://localhost:61616,tcp://remotehost://61616)</code>作为URL。</p>

<p>动态配置文件如下</p>

<pre><code>&lt;broker brokerName=&quot;receiver&quot; persistent=&quot;false&quot; useJmx=&quot;false&quot;&gt;
    &lt;transportConnectors&gt;
        &lt;transportConnector uri=&quot;tcp://localhost:61616&quot; discoveryUri=&quot;multicast://default&quot;/&gt;
    &lt;/transportConnectors&gt;
    &lt;networkConnectors&gt;
        &lt;networkConnector uri=&quot;multicast://default&quot;/&gt;
    &lt;/networkConnectors&gt;
&lt;/broker&gt; 
</code></pre>

<p>此时客户端在连接到ActiveMQ时，应使用<code>discovery://(multicast://default)</code>作为URL。</p>

<h1 id="总结">总结</h1>

<p>ActiveMQ作为一个高性能的消息队列，可以满足我们的使用需求，并且，其配置使用都还算简单，没有门槛，这是我最喜欢的地方。</p>

<p>最后，集群一节中，大量参考了<a href="http://wenku.baidu.com/view/6989622de2bd960590c67760.html">Ac​t​i​v​e​M​Q​集​群​的​使​用​与​配​置</a>一文，有关更多的集群配置内容，可以参考。</p>

    </div>
</div>
</div>

<h2 style="color: #777">评论</h2>
<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "evercoding" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


            
        </div>
    </div>
    <div id="footer">
    <div class="footer-container">
        <div class="support">
            <div class="powered-by">本站由 <a href="https://gohugo.io">Hugo</a> 驱动</div>
            <div class="theme">采用 <a href="https://github.com/codvim">ink</a> 主题</div>
        </div>
    </div>
</div>
    
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-54098391-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>

</body>
</html>